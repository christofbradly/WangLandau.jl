var documenterSearchIndex = {"docs":
[{"location":"api/#API-Index","page":"API","title":"API Index","text":"","category":"section"},{"location":"api/#WangLandau.WangLandau","page":"API","title":"WangLandau.WangLandau","text":"WangLandau\n\nThis is WangLandau 0.1.0-DEV.\n\n\n\n\n\n","category":"module"},{"location":"api/#WangLandau.CatchupStrategy","page":"API","title":"WangLandau.CatchupStrategy","text":"CatchupStrategy{B}\n\nStrategy for determining how to update the density of states when a new state is visited for the first time.\n\nThis occurs before the density of states is updated with parameter f.\n\nAPI: \n\ncatchup_enabled(strat::CatchupStrategy)\ncatchup_value(strat::CatchupStrategy, sim): only called if\n\nB == true\n\n\n\n\n\n","category":"type"},{"location":"api/#WangLandau.DosIncrementStrategy","page":"API","title":"WangLandau.DosIncrementStrategy","text":"DosIncrementStrategy\n\n\n\n\n\n","category":"type"},{"location":"api/#WangLandau.DynamicFractionalCatchup","page":"API","title":"WangLandau.DynamicFractionalCatchup","text":"DynamicFractionalCatchup() <: CatchupStrategy\n\nWhen a new state is visited for the first time, the density of states is set to a fraction of the smallest current non-zero value. The fraction is determined from the current value of \\log f.\n\n\n\n\n\n","category":"type"},{"location":"api/#WangLandau.FixedFractionalCatchup","page":"API","title":"WangLandau.FixedFractionalCatchup","text":"FixedFractionalCatchup(f) <: CatchupStrategy\n\nWhen a new state is visited for the first time, the density of states is set to a fixed fraction of the smallest current non-zero value.\n\n\n\n\n\n","category":"type"},{"location":"api/#WangLandau.FlatHistogramStrategy","page":"API","title":"WangLandau.FlatHistogramStrategy","text":"FlatHistogramStrategy\n\n\n\n\n\n","category":"type"},{"location":"api/#WangLandau.FractionOfMean","page":"API","title":"WangLandau.FractionOfMean","text":"FractionOfMean(tol)\n\nDefine the histogram flatness criterion to be when the smallest non-zero value is greater than tol times the mean, which is calculated from states that have at least min visits.\n\n\n\n\n\n","category":"type"},{"location":"api/#WangLandau.NoCatchup","page":"API","title":"WangLandau.NoCatchup","text":"NoCatchup() <: CatchupStrategy{false}\n\nThe default strategy, does nothing.\n\n\n\n\n\n","category":"type"},{"location":"api/#WangLandau.ReduceByFactor","page":"API","title":"WangLandau.ReduceByFactor","text":"ReduceByFactor(; kwargs...)\n\nA DosIncrementStrategy to control parameter log f by multiplying by a constant factor every time a flat histogram occurs, until a desired minimum value is achieved.\n\nKeyword arguments and their default values are:\n\ninitial = 1.0\nfactor = 0.5: must be less than 1\nfinal = 1e-6\n\n\n\n\n\n","category":"type"},{"location":"api/#WangLandau.StableNumVisits","page":"API","title":"WangLandau.StableNumVisits","text":"StableNumVisits(min, checksteps)\n\nDefine the histogram flatness criterion to be when the number of visited states remains constant for a number of steps checksteps. A state is considered visited if it has been sampled at least minvisits times.\n\nThis strategy may be more effective for two-dimensional state spaces (i.e. energy and order parameter), see e.g. Tsai, Wang & Landau, Braz. J. Phys. 38 2008 .\n\nSuggested parameters are min = 2000 and check = N * 10^6 for system size N.\n\n\n\n\n\n","category":"type"},{"location":"api/#WangLandau.WangLandauProblem","page":"API","title":"WangLandau.WangLandauProblem","text":"WangLandauProblem(statedefn::D)\n\nThis is a simple wrapper for the user-defined statedefn that enables the CommonSolve.jl interface. It can be overloaded so that statedefn does not have to be instantiated directly first.\n\n\n\n\n\n","category":"type"},{"location":"api/#WangLandau.WangLandauSimulation","page":"API","title":"WangLandau.WangLandauSimulation","text":"WangLandauSimulation()\n\nKeyword arguments:\n\ncheck_sweeps = 100: The number of sweeps to perform before checking for flatness. A sweep is N steps where N is the size of the system. See system_size.\nmax_total_steps = Inf:\nfinal_logf = 1e-6: when log f reaches this value the simulation ends.\nlogf_strategy = ReduceByFactor(; final = final_logf): Controls how f is updated. Overrides final_logf.\ntol = 0.8: Set tolerance for the flatness of the histogram.\nflat_strategy = FractionOfMean(tol): Define the flatness criterion for the histogram. Overrides tol.\ntasks_per_thread = 4: a multiplier for determining the number of tasks to @spawn. Set to 0 to disable concurrent threads even if more than one thread is running.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonSolve.init-Tuple{WangLandauProblem}","page":"API","title":"CommonSolve.init","text":"CommonSolve.init(problem::WangLandauProblem; kwargs...) -> WangLandauSimulation\n\nInitialise a WangLandauSimulation based on problem.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonSolve.solve","page":"API","title":"CommonSolve.solve","text":"CommonSolve.solve(::WangLandauProblem)::WangLandauSimulation\n\n\n\n\n\n","category":"function"},{"location":"api/#CommonSolve.solve!-Tuple{WangLandau.WangLandauSimulation}","page":"API","title":"CommonSolve.solve!","text":"CommonSolve.solve!(sim::WangLandauSimulation; kwargs...)\n\nRun WangLandau algorithm on sim.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonSolve.step!-Tuple{WangLandau.WangLandauSimulation, Any, Any, Any}","page":"API","title":"CommonSolve.step!","text":"CommonSolve.step!(sim::WangLandauSimulation, histogram)\n\nRun sim for a single iteration until the histogram is flat.\n\n\n\n\n\n","category":"method"},{"location":"api/#WangLandau.catchup_enabled-Union{Tuple{CatchupStrategy{B}}, Tuple{B}} where B","page":"API","title":"WangLandau.catchup_enabled","text":"catchup_enabled(strat)\n\n\n\n\n\n","category":"method"},{"location":"api/#WangLandau.catchup_value","page":"API","title":"WangLandau.catchup_value","text":"catchup_value(strat)\n\n\n\n\n\n","category":"function"},{"location":"api/#WangLandau.commit_trial!","page":"API","title":"WangLandau.commit_trial!","text":"commit_trial!(state::S, statedefn::D, trial::T, old_index::I, new_index::I)\n\nUpdate state by applying the trial move, using information from old_index and new_index, if necessary. \n\nSee also random_trial!, revert_trial!.\n\n\n\n\n\n","category":"function"},{"location":"api/#WangLandau.current_value","page":"API","title":"WangLandau.current_value","text":"current_value(strat)\n\nReturn the current value of log f from the strat.\n\n\n\n\n\n","category":"function"},{"location":"api/#WangLandau.expected_iterations","page":"API","title":"WangLandau.expected_iterations","text":"expected_iterations(strat)\n\n\n\n\n\n","category":"function"},{"location":"api/#WangLandau.final_value","page":"API","title":"WangLandau.final_value","text":"final_value(strat)\n\nReturn the final value of log f from the strat.\n\n\n\n\n\n","category":"function"},{"location":"api/#WangLandau.histogram_index","page":"API","title":"WangLandau.histogram_index","text":"histogram_index(state::S, statedefn::D, trial::T, old_index::I) -> new_index::I\n\nCalculate the new_index for accessing the density of states, using statedefn, trial or old_index, if necessary.\n\nSee also random_trial!.\n\n\n\n\n\n","category":"function"},{"location":"api/#WangLandau.histogram_size","page":"API","title":"WangLandau.histogram_size","text":"histogram_size(statedefn::D)\n\nReturn a Tuple of integers that specify the size of the histograms. The first is canonically the number of possible energy levels accessible by statedefn.\n\n\n\n\n\n","category":"function"},{"location":"api/#WangLandau.initialise_state","page":"API","title":"WangLandau.initialise_state","text":"initialise_state(statedefn::D) -> (state::S, index::I)\n\nInitialise a new state::S for use in a WangLandauSimulation based on the definition statedefn::D provided to WangLandauProblem. D and S are defined by the user and D should be immutable. This function could copy a configuration that is stored in statedefn, but ideally it should reseed a new configuration. Called from CommonSolve.solve! to seed multiple threads.\n\n\n\n\n\n","category":"function"},{"location":"api/#WangLandau.isconverged","page":"API","title":"WangLandau.isconverged","text":"isconverged(strat)\n\n\n\n\n\n","category":"function"},{"location":"api/#WangLandau.isflat","page":"API","title":"WangLandau.isflat","text":"isflat(strat, hist)::Bool\n\nChecks if histogram hist is flat according to the FlatHistogramStrategy.\n\n\n\n\n\n","category":"function"},{"location":"api/#WangLandau.random_trial!","page":"API","title":"WangLandau.random_trial!","text":"random_trial!(state::S, statedefn::D) -> trial::T\n\nCalculate a random trial move for state based on statedefn.\n\nIf a trial move cannot be found returns nothing.\n\nSee also commit_trial!, revert_trial!.\n\n\n\n\n\n","category":"function"},{"location":"api/#WangLandau.revert_trial!-NTuple{5, Any}","page":"API","title":"WangLandau.revert_trial!","text":"revert_trial!(state::S, statedefn::D, trial::T, old_index::I, new_index::I)\n\nReturns state to before trial move was performed, using information from old_index and new_index, if necessary. \n\nBy default this returns state unaltered. Alternatively, if this method is defined, then it should be sufficient to define amethod for commit_trial! that returns state unaltered.\n\nSee also random_trial!, commit_trial!.\n\n\n\n\n\n","category":"method"},{"location":"api/#WangLandau.system_size","page":"API","title":"WangLandau.system_size","text":"system_size(statedefn::D)\n\nGet the canonical size of statedefn, e.g. the number of lattice sites. Used to determine the size of a Monte Carlo sweep.\n\n\n\n\n\n","category":"function"},{"location":"api/#WangLandau.update!","page":"API","title":"WangLandau.update!","text":"update!(strat)\n\n\n\n\n\n","category":"function"},{"location":"api/#WangLandau.update!-Tuple{CatchupStrategy, Any}","page":"API","title":"WangLandau.update!","text":"update!(strat, sim)\n\n\n\n\n\n","category":"method"},{"location":"api/#WangLandau.update!-Tuple{FlatHistogramStrategy, Any}","page":"API","title":"WangLandau.update!","text":"update!(strat, sim)\n\nOptionally update strat with information from the simulation sim. Returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#WangLandau.wl_trial!-Union{Tuple{C}, Tuple{Any, Any, Any, Any, Any, Any, CatchupStrategy{C}}} where C","page":"API","title":"WangLandau.wl_trial!","text":"wl_trial!(state, old_index, statedefn, logdos, temp_hist, logf, catchup) -> new_index\n\nObtain a single trial move, compare to current state and commit or reject. Then increment the density of states logdos and histogram temp_hist, with logf and 1, respectively.\n\n\n\n\n\n","category":"method"},{"location":"ising/#Example:-2D-Ising-model","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"","category":"section"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"Pages = [\"ising.md\"]\nDepth = 2:3","category":"page"},{"location":"ising/#The-Ising-model","page":"Example: 2D Ising model","title":"The Ising model","text":"","category":"section"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"The Ising model is a classic statistical mechanics model defined by a Hamiltonian","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"H = -J sum_i sim j S_i S_j","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"where S_i in (-11) is the spin of site i. The sum is over all adjacent pairs on a specified lattice. Here we assume that the interaction strength is in units where J = 1 and we ignore any external magnetic field. We will apply this model on a square grid of size L times L sites. This model is the simplest statistical mechanical system that exhibits a continuous phase transition.","category":"page"},{"location":"ising/#Setup","page":"Example: 2D Ising model","title":"Setup","text":"","category":"section"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"To apply the Wang-Landau algorithm, we load WangLandau along with necessary definitions for the Ising model","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"using WangLandau, LinearAlgebra, Plots, LaTeXStrings;\n\ninclude(\"../../examples/ising.jl\");","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"The main definition in ising.jl is the mutable struct Ising2D, which holds an integer array representing the configuration of spins and the energy of the configuration. The rest of the code defines methods for applying the WangLandau interface to Ising2D (see WangLandauProblem). These methods define the histograms and specify how to make and accept random trial moves. For the Ising model a simple trial move is flipping a single spin at a random site on the lattice.","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"This example can have periodic or free boundary conditions, here we will define the problem for the case of free boundary conditions:","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"L = 15;\n\nP = false;\n\nprob = WangLandauProblem(Ising2D(L; periodic=P));","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"When Ising2D is constructed it will initialise a random configuration of spins.","category":"page"},{"location":"ising/#Simulation","page":"Example: 2D Ising model","title":"Simulation","text":"","category":"section"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"Next, we run the simulation. We will use the default strategies for altering the f parameter, but set a final desired value of f  10^-6. We can also set how often to check for flatness by setting the keyword check_sweeps. A single Monte Carlo sweep is N trial moves, where N is the canonical size of the system, in this case N = L^2.","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"sim = solve(prob; check_sweeps = 500, final_logf = 1e-6);","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"To see if the algorithm performed well, we should inspect the histogram of samples. The output sim.samples is the accumulation of the histogram at each iteration. ","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"scatter(sim.samples; label = :none, ylabel = \"samples\", msw = 0, ms = 2)","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"If the histogram is flat then we can proceed to analysis.","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"The samples histogram is indexed by i in 1ldotsi_mathrmmax, where i_mathrmmax = 2 (L - P)^2 + 2 (L - P) is the number of accessible energy values and P=0 for free boundary and P=1 for periodic boundary. This is more efficient for internal processing and the conversion to consecutive array indexing is handled by the Ising2D code. However, for physical analysis we want a range of real energy values. The extremal energy values for an L times L lattice are pm E_mathrmmax where E_mathrmmax = 2(L - (1 - P))^2 + 2(L - (1 - P)), and the change in energy from flipping a single spin is 2(1+P). In fact, E_mathrmmax is already stored in Ising2D so we can just define","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"maxE = sim.statedefn.maxE;\n\nEs = -maxE:(2*(1 + P)):maxE;","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"Next, we look at the density of states, normalised to its maximum value. We also apply a mask to avoid any hard-to-reach states that were not sampled.","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"mask = sim.samples .> 0;\n\nlogdos_shift = maximum(sim.logdos[mask]);\n\ndos = exp.(sim.logdos[mask] .- logdos_shift);\n\nscatter(Es[mask], dos; label = :none, xlabel = L\"E\", ylabel = L\"g(E)\", yscale = :log10, ms = 2, msw = 0)","category":"page"},{"location":"ising/#Critical-point","page":"Example: 2D Ising model","title":"Critical point","text":"","category":"section"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"The 2D Ising model has a continuous phase transition at beta_c J = log (1+sqrt2)  2 approx 044ldots, where beta is inverse temperature. The output of the simulation is the entropy log g(E), i.e. the logarithm of the density of states, from which we can calculate moments of the energy","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"langle E^n rangle = fracsum_E E^n g(E) exp(-beta E)sum_E g(E) exp(-beta E)","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"To compute moments of the density of states from the output data we define ","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"function moment_E(Es, g, n, β); E_factor = @. Es^n * exp(-Es * β); return dot(g, E_factor); end;","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"where Es is the range of energy values, g is the corresponding density of states, n is the desired moment and β is an inverse temperature value. Using this we compute the partition function, the average energy and the specific heat (energy variance) as the 0th, 1st and 2nd moments, for a range of values of beta","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"βs = 0.1:0.01:1.0;\n\nZ = [moment_E(Es[mask], dos, 0, β) for β in βs];\n\navgE = [moment_E(Es[mask], dos, 1, β) for β in βs];\n\navgE2 = [moment_E(Es[mask], dos, 2, β) for β in βs];\n\nvarE = @. (avgE2 / Z - (avgE / Z)^2) * βs^2;","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"Now we can plot the average energy","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"plot(βs, avgE ./ Z ./ maxE; label = :none, xlabel = L\"\\beta\", ylabel = L\"\\langle E \\rangle / E_\\mathrm{max}\", xlim = (0, Inf))","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"and the specific heat, or variance","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"plot(βs, varE ./ L^2; label = :none, xlabel = L\"\\beta\", ylabel = L\"\\mathrm{var}(E)\", xlim = (0, Inf), ylim = (0, Inf))","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"Finally, the peak of the specific heat is a signature of the location of the critical point","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"varE_max, varE_max_i = findmax(varE);\n\nvarE_max / L^2, βs[varE_max_i]","category":"page"},{"location":"ising/","page":"Example: 2D Ising model","title":"Example: 2D Ising model","text":"which compares well to the known value.","category":"page"},{"location":"advanced/#Advanced-Usage","page":"Advanced usage","title":"Advanced Usage","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Pages = [\"advanced.md\"]\nDepth = 2:3","category":"page"},{"location":"advanced/#Strategies","page":"Advanced usage","title":"Strategies","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"The Wang-Landau algorithm has rules for determining the histogram flatness and how to update `f. These can be controlled by via keyword arguments flat_strategy and logf_strategy passed to solve.","category":"page"},{"location":"advanced/#Histogram-flatness-criterion","page":"Advanced usage","title":"Histogram flatness criterion","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"The flatness criterion is defined by FlatHistogramStrategy. The default FlatHistogramStrategy is FractionOfMean which determines flatness by whether the minimum value of the histogram is at least a fraction x of the mean value. Because it is the default strategy, the parameter x can also be supplied directly to solve(prob; kwargs...) with the keyword argument flat_tolerance = x. A custom strat::FlatHistogramStrategy can be passed to the algorithm via solve(prob; flat_strategy = strat).","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Implemented flatness strategies include","category":"page"},{"location":"advanced/#WangLandau.FractionOfMean-advanced","page":"Advanced usage","title":"WangLandau.FractionOfMean","text":"FractionOfMean(tol)\n\nDefine the histogram flatness criterion to be when the smallest non-zero value is greater than tol times the mean, which is calculated from states that have at least min visits.\n\n\n\n\n\n","category":"type"},{"location":"advanced/#WangLandau.StableNumVisits-advanced","page":"Advanced usage","title":"WangLandau.StableNumVisits","text":"StableNumVisits(min, checksteps)\n\nDefine the histogram flatness criterion to be when the number of visited states remains constant for a number of steps checksteps. A state is considered visited if it has been sampled at least minvisits times.\n\nThis strategy may be more effective for two-dimensional state spaces (i.e. energy and order parameter), see e.g. Tsai, Wang & Landau, Braz. J. Phys. 38 2008 .\n\nSuggested parameters are min = 2000 and check = N * 10^6 for system size N.\n\n\n\n\n\n","category":"type"},{"location":"advanced/#Density-of-states-parameter-f","page":"Advanced usage","title":"Density of states parameter f","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"The alteration of f (actually log f) at each iteration is defined by DosIncrementStrategy. The default DosIncrementStrategy is ReduceByFactor which defines a parameter x (default x=0.5) and updates log f to x log f after each flatness iteration. It also defines initial and final values for log f with defaults 1.0 and 1e-6, respectively. Because it is the default strategy, the final value of log f can also be supplied directly to solve(prob; kwargs...) with the keyword argument final_logf. A custom strat::DosIncrementStrategy can be passed to the algorithm via solve(prob; logf_strategy = strat).","category":"page"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"Implemented log f strategies include","category":"page"},{"location":"advanced/#WangLandau.ReduceByFactor-advanced","page":"Advanced usage","title":"WangLandau.ReduceByFactor","text":"ReduceByFactor(; kwargs...)\n\nA DosIncrementStrategy to control parameter log f by multiplying by a constant factor every time a flat histogram occurs, until a desired minimum value is achieved.\n\nKeyword arguments and their default values are:\n\ninitial = 1.0\nfactor = 0.5: must be less than 1\nfinal = 1e-6\n\n\n\n\n\n","category":"type"},{"location":"advanced/#Other-features","page":"Advanced usage","title":"Other features","text":"","category":"section"},{"location":"advanced/","page":"Advanced usage","title":"Advanced usage","text":"parallelisation (multi-threading): implemented with @atomic. Prior to Julia v.1.12 this requires the Atomix.jl package\nparallelisation (replica exchange): TBC\nmulti-index histogram/dos: Typically the energy E is a well-defined physical property of the system being studied, but internally WangLandau.jl only treats it as an index to the histogram and density of states. Thus, one could have a system with two parameters of interest, e.g. energy and order parameter. See random_trial!\nuser defined DefType and StateType","category":"page"},{"location":"#WangLandau.jl","page":"Home","title":"WangLandau.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WangLandau.jl is a pure Julia implementation of the Wang-Landau Monte Carlo algorithm for statistical mechanics problems. The package defines a flexible interface that is designed to apply the algorithm to any user-defined problem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]\nDepth = 2:2","category":"page"},{"location":"#Wang-Landau-algorithm","page":"Home","title":"Wang-Landau algorithm","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The Wang-Landau algorithm works by randomly sampling from a state space and iteratively updating a corresponding density of states until some accuracy criterion is achieved. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Suppose we initialise a system in state i (e.g. an Ising configuration on a lattice), which has energy E_i, and we propose a trial move to state j, which has energy E_j. The proposed state is accepted based on a Metropolis-like condition","category":"page"},{"location":"","page":"Home","title":"Home","text":"P(i to j) = min left(1 fracg(E_i)g(E_j) right)","category":"page"},{"location":"","page":"Home","title":"Home","text":"where g(E) is the density of states at energy E. Classically, the density of states is motivated by the Boltzmann distribution g(E) = exp(-E). A random roll is performed against P(i to j) and either the proposed state or the original state is accepted as the next state. The sampled states are counted with a histogram h(E), initially set to 0. When the next state, with energy E, is accepted, h is incremented to count the new state: h(E) to h(E) + 1 and the density of states is increased according to g(E) to  f * g(E), where f is a dynamic parameter.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A single iteration of the Wang-Landau algorithm is as follows: After a set number of trial moves, the histogram is checked to see if it is sufficiently 'flat', for example, min h(E) geq 08 barh(E), where barh(E) is the average value of h. If the histogram is flat, then h is reset to 0, the parameter f is decreased, for example f to sqrtf, and a new iteration commences. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The algorithm terminates when f reaches a predetermined size, for example, one may initialise f = e approx 2718ldots and after 14 iterations f  10^-6. At this point the error in the density of states is sqrtf, and thermodynamic properties can be calculated from g(E). For numerical accuracy, the density of states and the parameter f are usually handled with logarithms.","category":"page"},{"location":"#Interface","page":"Home","title":"Interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WangLandau.jl adheres to the CommonSolve interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"prob = WangLandauProblem(::SetupType)\nsim = CommonSolve.solve(prob; kwargs...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The SetupType should be defined by the user for a specific problem. Several methods should be defined by the user to dispatch on SetupType, see below for details. The kwargs passed to solve define the parameters of the algorithm, and are ultimately passed to WangLandauSimulation, which is the main internal struct and the output type of sim. WangLandauSimulation is not exported and should not be constructed explicitly, it is handled via the CommonSolve interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main parameters include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"check_sweeps: A statistical mechanics problem will have some finite size N and a Monte Carlo sweep is N trial moves. check_sweeps controls how many sweeps to perform before checking if the histogram is flat. Checking too often can be inefficient and checking too rarely will mean the algorithm runs longer than necessary.\nflat_tolerance: defines the number x such that h(E) is considered flat when min h geq x barh\nfinal_logf: when f reaches this value the algorithm terminates","category":"page"},{"location":"","page":"Home","title":"Home","text":"The output sim::WangLandauSimulation will contain two Arrays:","category":"page"},{"location":"","page":"Home","title":"Home","text":"sim.samples: the histogram of samples h(E)\nsim.logdos: The (logarithm) of the density of states log g(E)","category":"page"},{"location":"#User-defined-code","page":"Home","title":"User-defined code","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To use WangLandau.jl the user should define a number of custom types and then several methods to act on those types. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The types referred to are","category":"page"},{"location":"","page":"Home","title":"Home","text":"SetupType: a struct that holds the necessary parameters to instantiate a sample configuration and define trial moves\nStateType: a data-structure that contains the configuration \nTrialType: data that defines how to perform a trial move between two states\nIndexType: an index for the histogram","category":"page"},{"location":"","page":"Home","title":"Home","text":"These types can be simple, for example, a lattice-spin model like the Ising model may use Matrix{Int} for StateType, and then TrialType indexes a single element in the matrix to perform a spin flip. IndexType should be Int for one-parameter histograms, otherwise CartesianIndex should be used.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then the following methods should be defined","category":"page"},{"location":"","page":"Home","title":"Home","text":"histogram_size: the dimensions of the histogram.\nsystem_size: the size of the system.\ninitialise_state: Optional initialisation step.\nrandom_trial!: Obtain a trial move for a new state.\nhistogram_index: Obtain the histogram index for the new state\ncommit_trial!: Upon acceptance of the trial move, update the state, optionally according to the indices.\nrevert_trial!: Upon rejection of the trial move, update the state, optionally according to the indices. By default returns state","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Original paper: Wang & Landau, PRL 2001","category":"page"}]
}
